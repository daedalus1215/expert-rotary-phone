/**

* You are tasked with designing a function-based access control system. 
 * The system manages user access levels for different resource types based on the Principle of Least Privilege (PoLP). 
 * This means each type should only have the minimum level of access required.

* Requirements:
** Input:
*** You will be given an array of strings, where each string follows the pattern:
```
    {Type}-Management-{AccessLevel}
        {Type}: Represents a resource type (e.g., Case, Transcript, Exhibit, etc.).
        {AccessLevel}: Represents the access level (e.g., ReadAccess, ModifyAccess, or FullAccess).
        FullAccess > ModifyAccess > ReadAccess (in terms of privilege).
```

** Output: 
```
    [
    "Case-Management-ReadAccess",
    "Transcript-Management-ReadAccess",
    "Exhibit-Management-ReadAccess"
    ];
```
* Part 1:
** Write a function getLeastPrivilegeSubset(inputArray) that takes in the array of access strings and returns a subset of the original list. This subset should include only the lowest privilege access level for each type, ensuring compliance with PoLP.


* Part 2:
** Write another function hasAccess(subset, type, accessLevel) that takes:

*** The subset generated by getLeastPrivilegeSubset.
**** A required accessLevel.
**** A type to check against.
**** The function should return true if the user has the required access or higher for the given type, and false otherwise.

** For example:
```
    hasAccess(subset, "Case", "ModifyAccess"); // true
    hasAccess(subset, "Transcript", "ModifyAccess"); // false
```
**/



function getLeastPrivilegeSubset(strings) {
    const accessPriority = {
        ReadAccess: 1,
        ModifyAccess: 2,
        FullAccess: 3
    };

    const accessMap = {};
    strings.forEach((str) => {
        const [type, _, accessLevel] = str.split('-');
        console.log('type', type);
        console.log('accessLevel', accessLevel);
        const currentLevel = accessPriority[accessLevel];

        if (!accessMap[type] || currentLevel < accessPriority[accessMap[type]]) {
            accessMap[type] = accessLevel;
        }
    });

    return strings.filter((str) => {
        const [type, , accessLevel] = str.split('-');
        return accessLevel === accessMap[type];
    });
}

function hasAccess(subset, typeToCheck, requiredAccess) {
    const accessPriority = {
        ReadAccess: 1,
        ModifyAccess: 2,
        FullAccess: 3
    };

    
    const typeAccess = subset.find((str) => str.startsWith(`${typeToCheck}-Management`));

    if (!typeAccess) return false; // If the type is not in the subset, no access

    const [, , userAccessLevel] = typeAccess.split('-');
    
    return accessPriority[userAccessLevel] >= accessPriority[requiredAccess];
}

describe('#principle of least privilege', () => {
    describe('#getLeastPrivilegeSubset', () => {
        it('should return the least privilege within that type of resource', () => {
            // Arrange
            const input = [
                "Case-Management-ReadAccess",
                "Case-Management-FullAccess",
                "Transcript-Management-ReadAccess",
                "Exhibit-Management-ModifyAccess",
                "Exhibit-Management-ReadAccess",
                "Video-Management-ModifyAccess",
                "Video-Management-FullAccess",
                "Confidential-Management-FullAccess"
            ];

            // Act
            const actual = getLeastPrivilegeSubset(input);

            // Assert
            expect(actual).toEqual(["Case-Management-ReadAccess", "Transcript-Management-ReadAccess", "Exhibit-Management-ReadAccess", "Video-Management-ModifyAccess", "Confidential-Management-FullAccess"]);
        });
    });

    describe('#hasAccess', () => {
        const subset = [
            "Case-Management-ReadAccess",
            "Transcript-Management-ReadAccess",
            "Exhibit-Management-ReadAccess",
            "Video-Management-ModifyAccess",
            "Confidential-Management-FullAccess"
        ];
        it('should determine if user can has access in a variety of scenarios', () => {
            // Arrange
            const subset = [
                "Case-Management-ReadAccess",
                "Transcript-Management-ReadAccess",
                "Exhibit-Management-ReadAccess",
                "Video-Management-ModifyAccess",
                "Confidential-Management-FullAccess"
            ];

            // Act
            const canModifyCase = hasAccess(subset, "Case", "ModifyAccess")
            const canDeleteCase = hasAccess(subset, "Case", "FullAccess")
            const canModifyTranscript = hasAccess(subset, "Transcript", "ModifyAccess")
            const canReadExhibit = (subset, "Exhibit", "ReadAccess")
            const canFullAccessConfidential = (subset, "Confidential", "FullAccess")

            // Assert
            expect(canModifyCase).toBe(false);
            expect(canDeleteCase).toBe(false);
            expect(canModifyTranscript).toBe(false);
            expect(canReadExhibit).toBe("ReadAccess");
            expect(canFullAccessConfidential).toBe("FullAccess");
        });
    });
});